package lang.ast;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class LangParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short RPARENTHESES = 2;
		static public final short COMMA = 3;
		static public final short SEMI = 4;
		static public final short INT = 5;
		static public final short BOOL = 6;
		static public final short VOID = 7;
		static public final short LPARENTHESES = 8;
		static public final short IF = 9;
		static public final short RBRACE = 10;
		static public final short WHILE = 11;
		static public final short RETURN = 12;
		static public final short NUMERAL = 13;
		static public final short EQ = 14;
		static public final short NEQ = 15;
		static public final short LE = 16;
		static public final short LT = 17;
		static public final short GE = 18;
		static public final short GT = 19;
		static public final short ADD = 20;
		static public final short MIN = 21;
		static public final short MUL = 22;
		static public final short DIV = 23;
		static public final short MOD = 24;
		static public final short TRUE = 25;
		static public final short FALSE = 26;
		static public final short LBRACE = 27;
		static public final short ASSIGN = 28;
		static public final short ELSE = 29;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"RPARENTHESES",
			"COMMA",
			"SEMI",
			"INT",
			"BOOL",
			"VOID",
			"LPARENTHESES",
			"IF",
			"RBRACE",
			"WHILE",
			"RETURN",
			"NUMERAL",
			"EQ",
			"NEQ",
			"LE",
			"LT",
			"GE",
			"GT",
			"ADD",
			"MIN",
			"MUL",
			"DIV",
			"MOD",
			"TRUE",
			"FALSE",
			"LBRACE",
			"ASSIGN",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjbbbiLLKKXjSvjy15g2Wp511aRE5Ie2rbAeWWWuWu0eAYe08EG8mQep7g4vhuOdpnIJ7" +
		"wP3JnmKGVZ2Cg5eKY85LGK1baa3A3GkdsMtllStjwXnP2r1Vld$#kTTRvzxJEdaGIAynwXR" +
		"Govy1wMIRBvG59oeCkdeKj5klbQkalVUKgAPDHCanw#NWcjYlIgcBf8JtDDs1xKqXlAP7Hf" +
		"bOHKqz0$IsepOcDYfXw8khVPPQBP#47HKnzZVIKrZBJnHlXUx9D4LDVIzr$WMqviLaHKqz5" +
		"$IVOd1FVATBgSTRh8yDSF0jRBQejVhMeDcV1rfpOPD4WRUKoKosXQR3usCSpKMDXR0#6qXV" +
		"txRlwU2Q#jpXlrPNqzxn2Idqy4pzQx5R8B9ac1NAVt2zBVJmDbs$f94ia8GzxpMyAcIupv3" +
		"eNaOUalHJAvT91hf0hfMCirztuZcDae0oImJ8a8pudYfjzSgEfrrRC8UbdwYq#LSZDSckwb" +
		"TaPhMYlRfVRfDni09yePBwaqlgA7Fexv4uP8IFDvnQVATBwHSsEeakUKGp84n#U9tvzdlWj" +
		"UU9tfREqm#8NXTmjzvWz2hdNnosaICPATnalLJ999iiKSz3D6dDGGQOEUfmnNqhAV845Kk4" +
		"iM8lcQxDEvldPLYutIJjPA3UOq#OhSZiB2oXnskEKh11#vfI2qgSyJX9C4J#fG7$IuuJOdp" +
		"cXG7$2uxZN7rUWF#vnpEkFAT0VypZgzKSLw8zw7F7w8mhqHppglBvEWRxEux3N7rQWF#nnn" +
		"kipCaH6tAynFtDjVYvSly3g3tZz0GNw0nvdV7zywIRrfDBrL53FOblFVg$Vhq2$tsCl#x$M" +
		"lrT1$NkzvrUnwvVv0ziPfk1AQOEjiBvQyKpP1bWrzbbjHAsZtCTSxvpMbZExB7PQ$Ao8ofc" +
		"V51AofnImkwXDIYls#pRMZw$Opgoxhgo3xbxTowlxi4hwIZ$EkURKZQh#hDEMwhuKTO445w" +
		"5ECex$lj#Hrvmw$fziiMvX$ndEsCRvhpcn1NNK0wSkk2XrU07z3fXT9VRiJELHQvtZqnfNQ" +
		"YoC8fLIQcVjAFRaSkPrqrn7EtPntdX1kkS5t9SQvxZBPjHALOvMXfFBm6gTleWIaRumfpwf" +
		"zxScusySrwMDuf#En$kiCyXvsVCX$XpuRBh$GEzKd5JjyG8o4RqjR19NzBw84gCDlsmziMG" +
		"wNXYF$w$$D$HyhLpwQBRRSdRrz$9Vjf8xQ19bqZuNyjPIQy7ggYdqDgBsAN0ntpkdTUMozy" +
		"QeNBHNhNhE7SkSyW4cwCRVKlWu364Irk2Mm4hUFuQT0kV0XN0PV1G#2ryKINI1fUYeEtm5j" +
		"eC3gMCBDW4duW$3piLI3sj5WfUmFU02okhvF9eOcc0wV0g#JEmHogp4lW3Ne2iZtXl$VUnR" +
		"y1ty3N0FWs$0daE$cdX7$Dduh#4NOz67hU56wj3#xyCkmb8ciHXsXSlHZg3S4knCthr9R2o" +
		"#jhy9VoZ#AkBlOXbxy0GnsWYUWUGj$12kWtruVXghOzy53$7yEbfo5xm7kHc6tA8Iv2NH0R" +
		"yzjWXB$I7tav0yX6CWROTJ8U#4N8JJi8nPQlstqxhQgi$ODxXOsA3Ml$#8zmEYv#Q8RatJP" +
		"#aKyoFxHam$8UQ$dRzUsHtJVT1oF#Hip7$Lsn9l9tixtzje3g$sjfusOlqEriRy6Tbj1JKn" +
		"dpaGp8izFwdVElQy8#RlXC#tD1QlBN8sB8gDouw5kqV0FKHWo0cVP0SG6C04#q78AIFsf2a" +
		"bbeiZMCSZuIZqLMYhY9MntvInrvHZcJqmv3GDESc2D0UXpyN#l1k0TGmu0nCn1foB4HFMze" +
		"FkrY0mW0dEJxtH1Enp0QizqBsENQ#HGs0n7EmvwMz6hf0E");

	static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
	// Disable syntax error recovery
	protected void recoverFromError(Symbol token, TokenStream in) {
		throw new SyntaxError("Cannot recover from the syntax error");
	}

	public LangParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 0: // program = func_list.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					 return new Program(a);
			}
			case 1: // func_list = 
			{
					 return new List();
			}
			case 2: // func_list = func_list.a func.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Func b = (Func) _symbol_b.value;
					 return a.add(b);
			}
			case 3: // func = type.t id_decl.a LPARENTHESES para_list.b RPARENTHESES LBRACE stmt_list.c RBRACE
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 4];
					final List b = (List) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final List c = (List) _symbol_c.value;
					 return new Func(t,a,b,c);
			}
			case 4: // para_list = 
			{
					 return new List();
			}
			case 5: // para_list = para.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Para a = (Para) _symbol_a.value;
					 return new List().add(a);
			}
			case 6: // para_list = para_list.a COMMA para.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Para b = (Para) _symbol_b.value;
					 return a.add(b);
			}
			case 7: // para = type.t id_decl.a
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					 return new Para(t,a);
			}
			case 8: // stmt_list = 
			{
					 return new List();
			}
			case 9: // stmt_list = stmt_list.a stmt.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					 return a.add(b);
			}
			case 16: // assign = id_use.a ASSIGN expr.b SEMI
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Assign(a,b);
			}
			case 17: // var_decl = type.t id_decl.a decl_opt.b SEMI
			{
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 2];
					final IdDecl a = (IdDecl) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Opt b = (Opt) _symbol_b.value;
					 return new VarDecl(t,a,b);
			}
			case 18: // ret = RETURN expr_opt.a SEMI
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Opt a = (Opt) _symbol_a.value;
					 return new Return(a);
			}
			case 19: // expr_opt = 
			{
					 return new Opt();
			}
			case 20: // expr_opt = expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new Opt(a);
			}
			case 21: // if_stmt = IF LPARENTHESES expr.a RPARENTHESES LBRACE stmt_list.b RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new IfStmt(a,b,new List());
			}
			case 22: // if_stmt = IF LPARENTHESES expr.a RPARENTHESES LBRACE stmt_list.b RBRACE ELSE LBRACE stmt_list.c RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 10];
					final List c = (List) _symbol_c.value;
					 return new IfStmt(a,b,c);
			}
			case 23: // while_stmt = WHILE LPARENTHESES expr.a RPARENTHESES LBRACE stmt_list.b RBRACE
			{
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 6];
					final List b = (List) _symbol_b.value;
					 return new WhileStmt(a,b);
			}
			case 24: // decl_opt = 
			{
					 return new Opt();
			}
			case 25: // decl_opt = ASSIGN expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return new Opt(a);
			}
			case 26: // funccallstmt = call.a SEMI
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Call a = (Call) _symbol_a.value;
					 return new FuncCallStmt(a);
			}
			case 30: // comparison = arithmetic.a EQ arithmetic.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Eq(a,b);
			}
			case 31: // comparison = arithmetic.a NEQ arithmetic.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Neq(a,b);
			}
			case 32: // comparison = arithmetic.a LE arithmetic.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Le(a,b);
			}
			case 33: // comparison = arithmetic.a LT arithmetic.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Lt(a,b);
			}
			case 34: // comparison = arithmetic.a GE arithmetic.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Ge(a,b);
			}
			case 35: // comparison = arithmetic.a GT arithmetic.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Gt(a,b);
			}
			case 37: // add = add.a ADD mul.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Add(a,b);
			}
			case 38: // add = add.a MIN mul.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Min(a,b);
			}
			case 40: // mul = mul.a MUL factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mul(a,b);
			}
			case 41: // mul = mul.a DIV factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Div(a,b);
			}
			case 42: // mul = mul.a MOD factor.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return new Mod(a,b);
			}
			case 46: // factor = LPARENTHESES expr.a RPARENTHESES
			{
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return a;
			}
			case 48: // number = NUMERAL.num
			{
					final Symbol num = _symbols[offset + 1];
					 return new Numeral(num);
			}
			case 49: // call = id_use.a LPARENTHESES expr_list.b RPARENTHESES
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final IdUse a = (IdUse) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final List b = (List) _symbol_b.value;
					 return new Call(a,b);
			}
			case 50: // expr_list = 
			{
					 return new List();
			}
			case 51: // expr_list = expr.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return new List().add(a);
			}
			case 52: // expr_list = expr_list.a COMMA expr.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final List a = (List) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return a.add(b);
			}
			case 53: // id_use = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdUse(id);
			}
			case 54: // id_decl = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdDecl(id);
			}
			case 55: // type_int = INT
			{
					 return new IntType();
			}
			case 56: // type_bool = BOOL
			{
					 return new BoolType();
			}
			case 57: // type_void = VOID
			{
					 return new VoidType();
			}
			case 61: // bool_true = TRUE
			{
					 return new BoolTrue();
			}
			case 62: // bool_false = FALSE
			{
					 return new BoolFalse();
			}
			case 10: // stmt = assign
			case 11: // stmt = var_decl
			case 12: // stmt = ret
			case 13: // stmt = if_stmt
			case 14: // stmt = while_stmt
			case 15: // stmt = funccallstmt
			case 27: // expr = arithmetic
			case 28: // expr = comparison
			case 29: // expr = bool_expr
			case 36: // arithmetic = add
			case 39: // add = mul
			case 43: // mul = factor
			case 44: // factor = id_use
			case 45: // factor = number
			case 47: // factor = call
			case 58: // type = type_int
			case 59: // type = type_bool
			case 60: // type = type_void
			case 63: // bool_expr = bool_true
			case 64: // bool_expr = bool_false
			{
				return _symbols[offset + 1];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
